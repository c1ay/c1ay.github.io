<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on c1ay</title>
    <link>https://c1ay.github.io/blog/</link>
    <description>Recent content in Blog on c1ay</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Feb 2017 20:41:19 +0800</lastBuildDate>
    <atom:link href="https://c1ay.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>（转）a simple introduction to computer networking</title>
      <link>https://c1ay.github.io/blog/%E8%BD%ACa-simple-introduction-to-computer-networking/</link>
      <pubDate>Fri, 17 Feb 2017 20:41:19 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/%E8%BD%ACa-simple-introduction-to-computer-networking/</guid>
      <description>

&lt;p&gt;大多数关于计算机网络的都是一大堆首字母缩写。忘掉这些配置细节&amp;mdash;-你有什么看法？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网络是关于通信&lt;/li&gt;
&lt;li&gt;文本是最简单的沟通方式&lt;/li&gt;
&lt;li&gt;协议是读和写这些文本的标准&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在细节下面，网络是一个IM对话。这是我希望有人告诉我，当学习如何计算机通信。&lt;/p&gt;

&lt;h3 id=&#34;tcp-文本层:6f45369c593e461cb825c990e56a083c&#34;&gt;&lt;em&gt;TCP: 文本层&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;传输控制协议（TCP）让我们有了很方便在两台计算机之间发送文本的错觉。 TCP依赖于较低级别并且可以发送二进制数据，但是现在忽略它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP允许我们在计算机之间进行即时消息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We IM with Telnet, the ‘notepad’ of networking: telnet sends and receives plain text using TCP. It’s a chat client peacefully free of ads and unsolicited buddy requests.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>tornado method-based URL dispatch</title>
      <link>https://c1ay.github.io/blog/tornado-method-based-url-dispatch/</link>
      <pubDate>Wed, 17 Aug 2016 14:33:27 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/tornado-method-based-url-dispatch/</guid>
      <description>

&lt;h3 id=&#34;基于-method-的url-分发:2e37154bfebd3b75369897c84945823f&#34;&gt;基于 method 的URL 分发&lt;/h3&gt;

&lt;h4 id=&#34;问题:2e37154bfebd3b75369897c84945823f&#34;&gt;问题:&lt;/h4&gt;

&lt;p&gt;如果我要完成同一层级下不同url的get请求, 只能写成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tornado.web import RequestHandler

class InterfaceOne(RequestHandler):

    def get(self):
        self.write(&#39;InterfaceOne&#39;)

class InterfaceTwo(RequestHandler):

    def get(self):
        self.write(&#39;InterfaceTwo&#39;)

application = tornado.web.Application([
    (r&amp;quot;/level_1/interface_one&amp;quot;, InterfaceOne),
    (r&amp;quot;/level_1/interface_two&amp;quot;, InterfaceTwo),
])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我不想每个接口都要写一个类去处理，而这些请求只需要处理&lt;code&gt;GET&lt;/code&gt;请求，还要为每个类去注册&lt;code&gt;url&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有没有什么解决方案去处理呢，加上我又很懒，最好&lt;code&gt;url&lt;/code&gt;也能自己生成. 像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Level:

    def interface_one(self):
        # 处理 url /level/interface_one 的请求
        pass

    def interface_two(self):
        # 处理 url /level/interface_two 的请求
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;解决方案:2e37154bfebd3b75369897c84945823f&#34;&gt;解决方案:&lt;/h4&gt;

&lt;p&gt;最终效果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Test(MethodDispatcher):

    def interface_one(self):
        # 处理 url /test/interface_one 的请求
        self.write(self.request.path)

    def interface_two(self):
        # 处理 url /test/interface_two 的请求
        self.write(self.request.path)

application = tornado.web.Application([
    (r&amp;quot;/test/.*&amp;quot;, Test),
])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MethodDispatcher&lt;/code&gt; 最终的实现&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/c1ay/06554e6fc6e36803b40d2359ff1adbf1.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://code.activestate.com/recipes/576958/&#34;&gt;http://code.activestate.com/recipes/576958/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>zsh to fish</title>
      <link>https://c1ay.github.io/blog/zsh-to-fish/</link>
      <pubDate>Wed, 16 Mar 2016 14:45:35 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/zsh-to-fish/</guid>
      <description>

&lt;p&gt;顺手的工具有不少，原来用&lt;code&gt;zsh&lt;/code&gt;虽然很顺手，但总觉得有点慢，索性试了试&lt;code&gt;fish&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;zsh-和-fish-对比:56d9c163c3c213e17f04852f404a0102&#34;&gt;zsh 和 fish 对比&lt;/h3&gt;

&lt;h4 id=&#34;zsh:56d9c163c3c213e17f04852f404a0102&#34;&gt;zsh&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;插件多，配置丰富&lt;/li&gt;
&lt;li&gt;插件多了慢&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;fish:56d9c163c3c213e17f04852f404a0102&#34;&gt;fish&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;开箱即用&lt;/li&gt;
&lt;li&gt;不兼容bash语法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;我需求的功能:56d9c163c3c213e17f04852f404a0102&#34;&gt;我需求的功能&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;autosuggestion&lt;/li&gt;
&lt;li&gt;autojump&lt;/li&gt;
&lt;li&gt;theme&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然fish的语法更加接近一名编程语言，奈何大多数工具脚本都是bash写的，而服务器上更不可能为了方便而安装fish,还是自己电脑上用好了&lt;/p&gt;

&lt;p&gt;不过发现&lt;code&gt;python&lt;/code&gt; 的virtualenvl 的activate的有fishshell 支持的！！&lt;/p&gt;

&lt;h3 id=&#34;一些语法改动:56d9c163c3c213e17f04852f404a0102&#34;&gt;一些语法改动&lt;/h3&gt;

&lt;p&gt;PATH 写法&lt;/p&gt;

&lt;p&gt;bash:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PATH=&amp;quot;/usr/local/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fish:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;set PATH $PATH /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fish配置:56d9c163c3c213e17f04852f404a0102&#34;&gt;fish配置&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;fish_config&lt;/code&gt;，新开一个网页来配置主题，函数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/fish_config.png&#34; alt=&#34;fish_config&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;fish插件管理工具-omf:56d9c163c3c213e17f04852f404a0102&#34;&gt;fish插件管理工具 &lt;code&gt;omf&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&#34;安装omf:56d9c163c3c213e17f04852f404a0102&#34;&gt;安装omf&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;curl -L https://get.oh-my.fish | fish&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;使用新主题:56d9c163c3c213e17f04852f404a0102&#34;&gt;使用新主题&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;omf install robbyrussell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;omf theme robbyrussell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个主题对git的支持很完善&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/robbyrussell.png&#34; alt=&#34;robbyrussell&#34;&gt;&lt;/p&gt;

&lt;p&gt;错误的也会有红色标记， 同时也会根据历史和命令给出建议&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/cut_1.png&#34; alt=&#34;cut_1&#34;&gt;&lt;/p&gt;

&lt;h4 id=&#34;提供对-bash-脚本支持:56d9c163c3c213e17f04852f404a0102&#34;&gt;提供对&lt;code&gt;bash&lt;/code&gt; 脚本支持&lt;/h4&gt;

&lt;p&gt;在fishshell里用bass来支持bash脚本
安装&lt;code&gt;bass&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/edc/bass.git&lt;/code&gt;
&lt;code&gt;make install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;bass使用效果, 这样就可以把以前的脚本迁移过来了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/bass.png&#34; alt=&#34;bass&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>https://c1ay.github.io/blog/hugo/</link>
      <pubDate>Thu, 14 Jan 2016 13:35:32 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/hugo/</guid>
      <description>

&lt;h2 id=&#34;使用hugo:32ab7241d48fcc174c877413a917f8cf&#34;&gt;使用hugo:&lt;/h2&gt;

&lt;p&gt;一直想学习&lt;code&gt;golang&lt;/code&gt;，看到了&lt;code&gt;hugo&lt;/code&gt;，想用hugo弄个博客，找到官方网站，跟着文档一步步来，安装，选主题，配置，没什么问题。步骤和&lt;code&gt;hexo&lt;/code&gt;一样。&lt;/p&gt;

&lt;h2 id=&#34;踩坑:32ab7241d48fcc174c877413a917f8cf&#34;&gt;踩坑:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一个坑：使用持续集成&amp;mdash;&lt;code&gt;wercker&lt;/code&gt;，官方文档中使用的&lt;code&gt;wercker&lt;/code&gt;，应该是以前的版本，新版本已经将deploy去掉，变成可配置的工作流，需要自己加一个pipline&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二个坑：文档中是没有例子怎么将网站push到github pages，使用&lt;code&gt;leipert/git-push&lt;/code&gt; push到github，这个项目是有bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run.sh: line 5: getAllStepVars: command not found
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个作者已经很久更新了，而且issue里是有人提了这个bug，也提交了pr，作者也没有更新。所以换做&lt;code&gt;ysqi/git-push&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用-ci-持续集成:32ab7241d48fcc174c877413a917f8cf&#34;&gt;使用&lt;code&gt;CI&lt;/code&gt;(持续集成):&lt;/h2&gt;

&lt;p&gt;持续集成，我的感觉是将软件发布的流程自动化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提交：对于开发者而言，是一次&lt;code&gt;commit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建：build, 将源码构建为实际运行代码&lt;/li&gt;
&lt;li&gt;测试：跑测试&lt;/li&gt;
&lt;li&gt;部署&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>