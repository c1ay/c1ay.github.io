<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on c1ay</title>
    <link>https://c1ay.github.io/blog/</link>
    <description>Recent content in Blog on c1ay</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 May 2017 11:10:23 +0800</lastBuildDate>
    <atom:link href="https://c1ay.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>python 加权随机</title>
      <link>https://c1ay.github.io/blog/python-%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA/</link>
      <pubDate>Thu, 25 May 2017 11:10:23 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/python-%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA/</guid>
      <description>&lt;p&gt;经常会遇到一种场景，从一堆数据中随机选择一个，一般用&lt;code&gt;random&lt;/code&gt;模块就能解决，如果这些数据被选择的概率不同，就需要在&lt;code&gt;random&lt;/code&gt;的基础上再做些改造。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/c1ay/8a89ebc4b6655f668d2390ef0779ee50.js&#34;&gt;&lt;/script&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;In [6]: WeightedRandomGenerator([1, 3, 4, 2])()
Out[6]: 2

In [7]: WeightedRandomGenerator([1, 3, 4, 2])()
Out[7]: 0

In [8]: WeightedRandomGenerator([1, 3, 4, 2])()
Out[8]: 2

In [9]: WeightedRandomGenerator([1, 3, 4, 2])()
Out[9]: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回随机结果的索引值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learn GraphQL -学习GraphQL（二）</title>
      <link>https://c1ay.github.io/blog/learn-graphql--%E5%AD%A6%E4%B9%A0graphql%E4%BA%8C/</link>
      <pubDate>Wed, 24 May 2017 10:00:11 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/learn-graphql--%E5%AD%A6%E4%B9%A0graphql%E4%BA%8C/</guid>
      <description>

&lt;h4 id=&#34;课程结构:b4db232a67c00c74b71eab1162a79b8e&#34;&gt;课程结构&lt;/h4&gt;

&lt;p&gt;我们一步步接受GraphQL，一个个的讲GraphQL的关键主题。也会在过程中问一些问题来检验你所学习到的。你也可以对遇到的疑问提出问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;可以跳过这些问题。但是要尝试解决这些问题，它们很简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;需要的基础知识:b4db232a67c00c74b71eab1162a79b8e&#34;&gt;需要的基础知识&lt;/h4&gt;

&lt;p&gt;我们会从最基础的开始，所以不需要任何GraphQL的基础，但是，需要还不错的JavaScript基础。我们会使用 &lt;a href=&#34;https://github.com/ericdouglas/ES6-Learning&#34;&gt;ES2015&lt;/a&gt; 语法，可以在 &lt;a href=&#34;https://github.com/lukehoban/es6features&#34;&gt;这儿&lt;/a&gt;学习。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们会在写GraphQL的结构时使用Node.js。没有任何NodeJS的经验也可以学习哦。（要先在你的系统里装上NodeJS）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有些课程需要克隆一个仓库来执行一些任务。所以，你需要基本的Git知识。&lt;/p&gt;

&lt;h4 id=&#34;graphql沙盒环境:b4db232a67c00c74b71eab1162a79b8e&#34;&gt;GraphQL沙盒环境&lt;/h4&gt;

&lt;p&gt;开头几节课程，我们会使用GraphQL查询语句。我们会使用已经定义好的GraphQL视图。下面是一个典型的博客视图的需求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;博客有许多文章&lt;/li&gt;
&lt;li&gt;每个文章有作者，也可能有多个评论&lt;/li&gt;
&lt;li&gt;每个评论也有一个作者&lt;/li&gt;
&lt;li&gt;每个评论也会有多个回复&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们会使用 &lt;a href=&#34;https://sandbox.learngraphql.com/&#34;&gt;GraphQL Sandbox&lt;/a&gt;来和这个视图交互。 &lt;a href=&#34;https://github.com/graphql/graphiql&#34;&gt;GraphiQL&lt;/a&gt;是一个开源的GraphQL编辑器。内置文档支持和自动补全。我们使用来学习课程，完成课程任务。&lt;/p&gt;

&lt;p&gt;观看下面的视频来熟悉这个工具。&lt;/p&gt;

&lt;iframe width=&#34;854&#34; height=&#34;480&#34; src=&#34;https://www.youtube.com/embed/Ou8PjP3dUI4&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h4 id=&#34;这个过程会很有趣:b4db232a67c00c74b71eab1162a79b8e&#34;&gt;这个过程会很有趣&lt;/h4&gt;

&lt;p&gt;我们会让每个课程都保持的很短，所以你可以利用碎片时间来学习。如果你喜欢这个课程，不要忘记分享和评论这个课程  : )&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learn GraphQL -了解GraphQl（一）</title>
      <link>https://c1ay.github.io/blog/learn-graphql--%E4%BA%86%E8%A7%A3graphql%E4%B8%80/</link>
      <pubDate>Tue, 23 May 2017 17:16:04 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/learn-graphql--%E4%BA%86%E8%A7%A3graphql%E4%B8%80/</guid>
      <description>

&lt;h4 id=&#34;graphql-简介:daac4e0304df38944c60b79ee78890c6&#34;&gt;GraphQL 简介:&lt;/h4&gt;

&lt;p&gt;GraphQL是Facebook出品的应用层查询语言。你可以用GraphQL明确的定义基于基于图形的schema。客户端就可以请求它所需要的数据集了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://cldup.com/ysnmIMhqRU.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以，你不需要因为客户端请求数据的变动更改你的后端，这简单的解决了使用REST API的最大的问题之一。&lt;/p&gt;

&lt;p&gt;GraphQL也允许让客户端高效的批量获取数据，比如下面就是一个GraphQL查询：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  latestPost {
    _id,
    title,
    content,
    author {
      name
    },
    comments {
      content,
      author {
        name
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是一个获取博客文章、评论以及作者信息的GraphQL请求，这是上面请求的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;data&amp;quot;: {
    &amp;quot;latestPost&amp;quot;: {
      &amp;quot;_id&amp;quot;: &amp;quot;03390abb5570ce03ae524397d215713b&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;New Feature: Tracking Error Status with Kadira&amp;quot;,
      &amp;quot;content&amp;quot;: &amp;quot;Here is a common feedback we received from our users ...&amp;quot;,
      &amp;quot;author&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;Pahan Sarathchandra&amp;quot;
      },
      &amp;quot;comments&amp;quot;: [
        {
          &amp;quot;content&amp;quot;: &amp;quot;This is a very good blog post&amp;quot;,
          &amp;quot;author&amp;quot;: {
            &amp;quot;name&amp;quot;: &amp;quot;Arunoda Susiripala&amp;quot;
          }
        },
        {
          &amp;quot;content&amp;quot;: &amp;quot;Keep up the good work&amp;quot;,
          &amp;quot;author&amp;quot;: {
            &amp;quot;name&amp;quot;: &amp;quot;Kasun Indi&amp;quot;
          }
        }
      ]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用REST, 则需要调用多个API 请求来获取这些数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GraphQL 是一个规范（标准）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以，它可以用于任何平台，任何编程语言。它有一个由Facebook维护的&lt;a href=&#34;https://github.com/graphql/graphql-js&#34;&gt;JavaScript&lt;/a&gt;实现参考。也有很多由社区维护的其它语言&lt;a href=&#34;https://github.com/chentsulin/awesome-graphql#table-of-contents&#34;&gt;实现&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这里是标准: &lt;a href=&#34;http://facebook.github.io/graphql/&#34;&gt;http://facebook.github.io/graphql/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦你使用了GraphQL，你会想在所有项目都使用它&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python 中获取当前模块名</title>
      <link>https://c1ay.github.io/blog/python-%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%A8%A1%E5%9D%97%E5%90%8D/</link>
      <pubDate>Wed, 10 May 2017 15:00:43 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/python-%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%A8%A1%E5%9D%97%E5%90%8D/</guid>
      <description>&lt;p&gt;今天在看&lt;a href=&#34;https://github.com/channelcat/sanic&#34;&gt;sanic&lt;/a&gt;的实现时，看到 &lt;a href=&#34;https://github.com/channelcat/sanic/blob/master/sanic/app.py#L45&#34;&gt;app.py&lt;/a&gt;, 其中&lt;code&gt;stack&lt;/code&gt;和&lt;code&gt;getmodulename&lt;/code&gt;均从&lt;code&gt;inspect&lt;/code&gt;模块导入，&lt;code&gt;inspect&lt;/code&gt;模块主要为&lt;code&gt;python&lt;/code&gt;提供自省功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Get name from previous stack frame
if name is None:
    frame_records = stack()[1]
    name = getmodulename(frame_records[1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;python&lt;/code&gt;提供的&lt;code&gt;inspect&lt;/code&gt;模块获取前一帧的模块名&lt;/p&gt;

&lt;p&gt;&lt;code&gt;frame_records&lt;/code&gt;是一个&lt;code&gt;FrameInfo&lt;/code&gt;对象，打印出来如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;FrameInfo(frame=&amp;lt;frame object at 0x7f28a3732828&amp;gt;, filename=&#39;test.py&#39;, lineno=12, function=&#39;&amp;lt;module&amp;gt;&#39;, code_context=[&#39;print(foo(None))\n&#39;], index=0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可以获得当前的文件名，代码行数以及当前调用栈，现在能想到的用途是用在代码调试上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MIT 6.824</title>
      <link>https://c1ay.github.io/blog/mit-6.824/</link>
      <pubDate>Thu, 04 May 2017 09:37:13 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/mit-6.824/</guid>
      <description>

&lt;h3 id=&#34;前言:e0960773aecd094100b56404b29805c6&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;开了个新坑, &lt;a href=&#34;http://nil.csail.mit.edu/6.824/2016/index.html&#34;&gt;MIT6.824&lt;/a&gt;，最近准备开始学习大名鼎鼎的MIT6.824分布式系统课程。这里是练习的地址&lt;a href=&#34;https://github.com/c1ay/MIT6.824&#34;&gt;github.com/c1ay/MIT6.824&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;目录:e0960773aecd094100b56404b29805c6&#34;&gt;目录&lt;/h3&gt;

&lt;p&gt;pass&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>（转）a simple introduction to computer networking</title>
      <link>https://c1ay.github.io/blog/%E8%BD%ACa-simple-introduction-to-computer-networking/</link>
      <pubDate>Fri, 17 Feb 2017 20:41:19 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/%E8%BD%ACa-simple-introduction-to-computer-networking/</guid>
      <description>

&lt;p&gt;大多数关于计算机网络的都是一大堆首字母缩写。忘掉这些配置细节&amp;mdash;-你有什么看法？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网络是关于通信&lt;/li&gt;
&lt;li&gt;文本是最简单的沟通方式&lt;/li&gt;
&lt;li&gt;协议是读和写这些文本的标准&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在细节下面，网络是一个IM对话。这是我希望有人告诉我，当学习如何计算机通信。&lt;/p&gt;

&lt;h3 id=&#34;tcp-文本层:6f45369c593e461cb825c990e56a083c&#34;&gt;&lt;em&gt;TCP: 文本层&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;传输控制协议（TCP）让我们有了很方便在两台计算机之间发送文本的错觉。 TCP依赖于较低级别并且可以发送二进制数据，但是现在忽略它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP允许我们在计算机之间进行即时消息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We IM with Telnet, the ‘notepad’ of networking: telnet sends and receives plain text using TCP. It’s a chat client peacefully free of ads and unsolicited buddy requests.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>tornado method-based URL dispatch</title>
      <link>https://c1ay.github.io/blog/tornado-method-based-url-dispatch/</link>
      <pubDate>Wed, 17 Aug 2016 14:33:27 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/tornado-method-based-url-dispatch/</guid>
      <description>

&lt;h3 id=&#34;基于-method-的url-分发:2e37154bfebd3b75369897c84945823f&#34;&gt;基于 method 的URL 分发&lt;/h3&gt;

&lt;h4 id=&#34;问题:2e37154bfebd3b75369897c84945823f&#34;&gt;问题:&lt;/h4&gt;

&lt;p&gt;如果我要完成同一层级下不同url的get请求, 只能写成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tornado.web import RequestHandler

class InterfaceOne(RequestHandler):

    def get(self):
        self.write(&#39;InterfaceOne&#39;)

class InterfaceTwo(RequestHandler):

    def get(self):
        self.write(&#39;InterfaceTwo&#39;)

application = tornado.web.Application([
    (r&amp;quot;/level_1/interface_one&amp;quot;, InterfaceOne),
    (r&amp;quot;/level_1/interface_two&amp;quot;, InterfaceTwo),
])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我不想每个接口都要写一个类去处理，而这些请求只需要处理&lt;code&gt;GET&lt;/code&gt;请求，还要为每个类去注册&lt;code&gt;url&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有没有什么解决方案去处理呢，加上我又很懒，最好&lt;code&gt;url&lt;/code&gt;也能自己生成. 像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Level:

    def interface_one(self):
        # 处理 url /level/interface_one 的请求
        pass

    def interface_two(self):
        # 处理 url /level/interface_two 的请求
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;解决方案:2e37154bfebd3b75369897c84945823f&#34;&gt;解决方案:&lt;/h4&gt;

&lt;p&gt;最终效果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Test(MethodDispatcher):

    def interface_one(self):
        # 处理 url /test/interface_one 的请求
        self.write(self.request.path)

    def interface_two(self):
        # 处理 url /test/interface_two 的请求
        self.write(self.request.path)

application = tornado.web.Application([
    (r&amp;quot;/test/.*&amp;quot;, Test),
])

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MethodDispatcher&lt;/code&gt; 最终的实现&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/c1ay/06554e6fc6e36803b40d2359ff1adbf1.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;参考: &lt;a href=&#34;http://code.activestate.com/recipes/576958/&#34;&gt;http://code.activestate.com/recipes/576958/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>zsh to fish</title>
      <link>https://c1ay.github.io/blog/zsh-to-fish/</link>
      <pubDate>Wed, 16 Mar 2016 14:45:35 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/zsh-to-fish/</guid>
      <description>

&lt;p&gt;顺手的工具有不少，原来用&lt;code&gt;zsh&lt;/code&gt;虽然很顺手，但总觉得有点慢，索性试了试&lt;code&gt;fish&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;zsh-和-fish-对比:56d9c163c3c213e17f04852f404a0102&#34;&gt;zsh 和 fish 对比&lt;/h3&gt;

&lt;h4 id=&#34;zsh:56d9c163c3c213e17f04852f404a0102&#34;&gt;zsh&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;插件多，配置丰富&lt;/li&gt;
&lt;li&gt;插件多了慢&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;fish:56d9c163c3c213e17f04852f404a0102&#34;&gt;fish&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;开箱即用&lt;/li&gt;
&lt;li&gt;不兼容bash语法&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;我需求的功能:56d9c163c3c213e17f04852f404a0102&#34;&gt;我需求的功能&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;autosuggestion&lt;/li&gt;
&lt;li&gt;autojump&lt;/li&gt;
&lt;li&gt;theme&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然fish的语法更加接近一名编程语言，奈何大多数工具脚本都是bash写的，而服务器上更不可能为了方便而安装fish,还是自己电脑上用好了&lt;/p&gt;

&lt;p&gt;不过发现&lt;code&gt;python&lt;/code&gt; 的virtualenvl 的activate的有fishshell 支持的！！&lt;/p&gt;

&lt;h3 id=&#34;一些语法改动:56d9c163c3c213e17f04852f404a0102&#34;&gt;一些语法改动&lt;/h3&gt;

&lt;p&gt;PATH 写法&lt;/p&gt;

&lt;p&gt;bash:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export PATH=&amp;quot;/usr/local/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fish:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fish&#34;&gt;set PATH $PATH /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fish配置:56d9c163c3c213e17f04852f404a0102&#34;&gt;fish配置&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;fish_config&lt;/code&gt;，新开一个网页来配置主题，函数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/fish_config.png&#34; alt=&#34;fish_config&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;fish插件管理工具-omf:56d9c163c3c213e17f04852f404a0102&#34;&gt;fish插件管理工具 &lt;code&gt;omf&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&#34;安装omf:56d9c163c3c213e17f04852f404a0102&#34;&gt;安装omf&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;curl -L https://get.oh-my.fish | fish&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;使用新主题:56d9c163c3c213e17f04852f404a0102&#34;&gt;使用新主题&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;omf install robbyrussell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;omf theme robbyrussell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个主题对git的支持很完善&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/robbyrussell.png&#34; alt=&#34;robbyrussell&#34;&gt;&lt;/p&gt;

&lt;p&gt;错误的也会有红色标记， 同时也会根据历史和命令给出建议&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/cut_1.png&#34; alt=&#34;cut_1&#34;&gt;&lt;/p&gt;

&lt;h4 id=&#34;提供对-bash-脚本支持:56d9c163c3c213e17f04852f404a0102&#34;&gt;提供对&lt;code&gt;bash&lt;/code&gt; 脚本支持&lt;/h4&gt;

&lt;p&gt;在fishshell里用bass来支持bash脚本
安装&lt;code&gt;bass&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/edc/bass.git&lt;/code&gt;
&lt;code&gt;make install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;bass使用效果, 这样就可以把以前的脚本迁移过来了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://c1ay.github.io/img/bass.png&#34; alt=&#34;bass&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>https://c1ay.github.io/blog/hugo/</link>
      <pubDate>Thu, 14 Jan 2016 13:35:32 +0800</pubDate>
      
      <guid>https://c1ay.github.io/blog/hugo/</guid>
      <description>

&lt;h2 id=&#34;使用hugo:32ab7241d48fcc174c877413a917f8cf&#34;&gt;使用hugo:&lt;/h2&gt;

&lt;p&gt;一直想学习&lt;code&gt;golang&lt;/code&gt;，看到了&lt;code&gt;hugo&lt;/code&gt;，想用hugo弄个博客，找到官方网站，跟着文档一步步来，安装，选主题，配置，没什么问题。步骤和&lt;code&gt;hexo&lt;/code&gt;一样。&lt;/p&gt;

&lt;h2 id=&#34;踩坑:32ab7241d48fcc174c877413a917f8cf&#34;&gt;踩坑:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一个坑：使用持续集成&amp;mdash;&lt;code&gt;wercker&lt;/code&gt;，官方文档中使用的&lt;code&gt;wercker&lt;/code&gt;，应该是以前的版本，新版本已经将deploy去掉，变成可配置的工作流，需要自己加一个pipline&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二个坑：文档中是没有例子怎么将网站push到github pages，使用&lt;code&gt;leipert/git-push&lt;/code&gt; push到github，这个项目是有bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;run.sh: line 5: getAllStepVars: command not found
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个作者已经很久更新了，而且issue里是有人提了这个bug，也提交了pr，作者也没有更新。所以换做&lt;code&gt;ysqi/git-push&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用-ci-持续集成:32ab7241d48fcc174c877413a917f8cf&#34;&gt;使用&lt;code&gt;CI&lt;/code&gt;(持续集成):&lt;/h2&gt;

&lt;p&gt;持续集成，我的感觉是将软件发布的流程自动化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提交：对于开发者而言，是一次&lt;code&gt;commit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;构建：build, 将源码构建为实际运行代码&lt;/li&gt;
&lt;li&gt;测试：跑测试&lt;/li&gt;
&lt;li&gt;部署&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>